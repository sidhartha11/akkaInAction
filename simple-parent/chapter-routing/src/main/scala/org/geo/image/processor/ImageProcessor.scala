package org.geo.image.processor

import akka.actor.{ Actor, ActorSystem, Props, ActorRef, Terminated,PoisonPill,ActorLogging }
import akka.routing.ActorRefRoutee
import akka.routing.Router
import akka.pattern.ask
import akka.routing.RoundRobinRoutingLogic
import java.io.File
import scala.concurrent.duration._
import scala.concurrent.Await
import akka.util.Timeout

import aia.routing.DirectoryTraversal._
import java.awt.image.BufferedImage
import javax.imageio.ImageIO

import akka.routing.FromConfig
import org.slf4j.LoggerFactory

class IWorker(pipe: ActorRef) extends Actor with ActorLogging {
  var id = self.path.name
  log.info("IWorker initialized: id= %s".format(id))

  def receive = {

    case msg: FileLocation =>
      log.info("IWorker,FileLocation : Received message {} in Actor {}" , msg , self.path.name)
      pipe forward  msg.copy(bi = Some(getImage(msg)))
      
    case msg: Finished =>
      log.info("IWorker,Finished : Received message {} in Actor {}" , msg , self.path.name)
      pipe forward msg
    
    case msg: ActorRef =>
      log.info("IWorker,ActorRef : Received message {} in Actor {}" , msg , self.path.name)
     pipe forward msg 
  }
  
  def getImage(msg: FileLocation): BufferedImage = {
    ImageIO.read(new File(msg.fileno))
  }
}


object TestMaster extends App {

  def dir = "C:\\workarea\\fixed2\\"
  def filename = "imageProcessor.jpg"
  /** create an ActorSystem From which to create Actors **/
  val system = ActorSystem("TestMaster")
  val logger = LoggerFactory.getLogger("TestMaster")

  /**
   * IWriter actor
   * This actor acts as a recipient of all the messages generated by 
   * the Router's set of routees 
   * It basically writes the small image rect to the internal image
   * buffer until all the rects are consummed. And once all are consumed,
   * the complete image is written to disk.
   * 
   */
  val numberImages = 196
  val numberCols = 14 
  val numberRows = 14 
  val chunkWidth = 560
  val chunkHeight= 560
  val typ = 5 
  val generator = system.actorOf(Props( new ImageAccumulator(
    numberImages, /** number of images **/
    chunkWidth,   /** width **/
    chunkHeight,  /** height **/
    numberCols,   /** numbercols **/
    numberRows,   /** numberrows **/
    typ,          /** type **/
    dir,          /** directory **/
    filename      /** filename **/
      )
      )
      ,"imageprocessor")
  
  /**
   * This router is defined in the configuration file. It is defined as a 
   * balancing pool Router:
   *    actor {
   *    deployment {
   *            /poolRouter {
   *            router = balancing-pool
   *            nr-of-instances = 5 
   *        }
   *    }
   *    
   *    The balancing-pool will write to at most 5 instances of 
   *    the IWorker actor.
   */
  val router = system.actorOf(
      FromConfig.props(Props(new IWorker(generator))),"roundRobinRouter")
      
  implicit val timeout2 = Timeout(4 seconds)

  router ! router 
  (0 until numberRows) foreach {
    r => 
      (0 until numberCols) foreach {
        c => 
          logger.debug("filenumber = {}" , ( numberCols * r + c ))
          logger.debug("[{} , {}]" , chunkWidth * c  ,chunkHeight * r )
          val fileno = "%s%04d.jpg".format(dir, numberCols * r + c)
          val fileObj = FileLocation(fileno, chunkWidth * c, chunkHeight * r, None)
          router ! fileObj

      }
  }
  println("finished sending all messages")
}